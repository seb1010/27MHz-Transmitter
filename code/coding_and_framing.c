uint8_t* add_framing(uint8_t * frame_buffer){
  frame_buffer[0] = 0xaa;
  frame_buffer[1] = 0xaa; 
  frame_buffer[2] = 0xaa;
  frame_buffer[3] = 0x14;
  frame_buffer[4] = 0x37;
  frame_buffer[5] = 0x9b;

  return frame_buffer + 6;
}


const __memx uint8_t bch_lookup_low[16][13] = {

// lower unshifted lookup table
{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0},
{0x3,0xa0,0x52,0xed,0x78,0x22,0xc7,0x11,0x8b,0x3a,0x15,0xd7,0xe5},
{0x7,0x40,0xa5,0xda,0xf0,0x45,0x8e,0x23,0x16,0x74,0x2b,0xaf,0xca},
{0x4,0xe0,0xf7,0x37,0x88,0x67,0x49,0x32,0x9d,0x4e,0x3e,0x78,0x2f},
{0xe,0x81,0x4b,0xb5,0xe0,0x8b,0x1c,0x46,0x2c,0xe8,0x57,0x5f,0x94},
{0xd,0x21,0x19,0x58,0x98,0xa9,0xdb,0x57,0xa7,0xd2,0x42,0x88,0x71},
{0x9,0xc1,0xee,0x6f,0x10,0xce,0x92,0x65,0x3a,0x9c,0x7c,0xf0,0x5e},
{0xa,0x61,0xbc,0x82,0x68,0xec,0x55,0x74,0xb1,0xa6,0x69,0x27,0xbb},
{0xe,0xa2,0xc5,0x86,0xb9,0x34,0xff,0x9d,0xd2,0xea,0xbb,0x68,0xcd},
{0xd,0x2,0x97,0x6b,0xc1,0x16,0x38,0x8c,0x59,0xd0,0xae,0xbf,0x28},
{0x9,0xe2,0x60,0x5c,0x49,0x71,0x71,0xbe,0xc4,0x9e,0x90,0xc7,0x7},
{0xa,0x42,0x32,0xb1,0x31,0x53,0xb6,0xaf,0x4f,0xa4,0x85,0x10,0xe2},
{0x0,0x23,0x8e,0x33,0x59,0xbf,0xe3,0xdb,0xfe,0x2,0xec,0x37,0x59},
{0x3,0x83,0xdc,0xde,0x21,0x9d,0x24,0xca,0x75,0x38,0xf9,0xe0,0xbc},
{0x7,0x63,0x2b,0xe9,0xa9,0xfa,0x6d,0xf8,0xe8,0x76,0xc7,0x98,0x93},
{0x4,0xc3,0x79,0x4,0xd1,0xd8,0xaa,0xe9,0x63,0x4c,0xd2,0x4f,0x76}

};

const __memx uint8_t bch_lookup_high[16][13] = {
// upper shifted array

{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0},
{0x0,0x3a,0x5,0x2e,0xd7,0x82,0x2c,0x71,0x18,0xb3,0xa1,0x5d,0x7e},
{0x0,0x74,0xa,0x5d,0xaf,0x4,0x58,0xe2,0x31,0x67,0x42,0xba,0xfc},
{0x0,0x4e,0xf,0x73,0x78,0x86,0x74,0x93,0x29,0xd4,0xe3,0xe7,0x82},
{0x0,0xe8,0x14,0xbb,0x5e,0x8,0xb1,0xc4,0x62,0xce,0x85,0x75,0xf9},
{0x0,0xd2,0x11,0x95,0x89,0x8a,0x9d,0xb5,0x7a,0x7d,0x24,0x28,0x87},
{0x0,0x9c,0x1e,0xe6,0xf1,0xc,0xe9,0x26,0x53,0xa9,0xc7,0xcf,0x5},
{0x0,0xa6,0x1b,0xc8,0x26,0x8e,0xc5,0x57,0x4b,0x1a,0x66,0x92,0x7b},
{0x0,0xea,0x2c,0x58,0x6b,0x93,0x4f,0xf9,0xdd,0x2e,0xab,0xb6,0x8c},
{0x0,0xd0,0x29,0x76,0xbc,0x11,0x63,0x88,0xc5,0x9d,0xa,0xeb,0xf2},
{0x0,0x9e,0x26,0x5,0xc4,0x97,0x17,0x1b,0xec,0x49,0xe9,0xc,0x70},
{0x0,0xa4,0x23,0x2b,0x13,0x15,0x3b,0x6a,0xf4,0xfa,0x48,0x51,0xe},
{0x0,0x2,0x38,0xe3,0x35,0x9b,0xfe,0x3d,0xbf,0xe0,0x2e,0xc3,0x75},
{0x0,0x38,0x3d,0xcd,0xe2,0x19,0xd2,0x4c,0xa7,0x53,0x8f,0x9e,0xb},
{0x0,0x76,0x32,0xbe,0x9a,0x9f,0xa6,0xdf,0x8e,0x87,0x6c,0x79,0x89},
{0x0,0x4c,0x37,0x90,0x4d,0x1d,0x8a,0xae,0x96,0x34,0xcd,0x24,0xf7}

};

const __memx uint8_t bch_lookup_extra [] = { //extra bits for upper array
0x00,0x50,0xa0,0xf0,0x40,0x10,0xe0,0xb0,0xd0,0x80,0x70,0x20,0x90,0xc0,0x30,0x60
};


void encode_data(uint8_t* data_buffer){
  uint8_t data; 
  uint8_t rem[13];
  uint16_t rem_bits;
  uint8_t i, j;
  uint8_t lookup_val_high, lookup_val_low;


  for(i=0; i<13; i++)
    rem[i] = 0;

  for(i=0; i<19; i++){ // 19.625 data bytes to encode
    data = data_buffer[i] >> 4; // 4 most significant bits from data
    rem_bits = rem[0] & 0x0f; // get 4 most significant bits from remainder
    lookup_val_high = rem_bits ^ data; // address in lookup table for next rem


    // calculate remainder for this data byte
    for(j=0; j<13; j++)
      rem[j] ^= bch_lookup_high[lookup_val_high][j];

    data = data_buffer[i] & 0x0f;
    rem_bits = rem[1] >> 4;
    lookup_val_low = rem_bits ^ data;

    for(j=0; j<12; j++)
      rem[j] = rem[j + 1] ^ bch_lookup_low[lookup_val_low][j];
    rem[0] &= 0x0f;
    rem[12] = bch_lookup_low[lookup_val_low][12];
    

    rem[12] ^= bch_lookup_extra[lookup_val_high];
  }


  // we need to run for an additional 3 bits
  data = data_buffer[19] >> 5; // 3 msb 
  rem_bits = rem[0] >> 1; // 3 msb
  lookup_val_low = rem_bits ^ data;  
  for(j=0; j<12; j++){
    rem[j] = (rem[j] << 3) + (rem[j+1] >> 5); // shift everything 3 bits
    rem[j] ^= bch_lookup_low[lookup_val_low][j]; // do eor
  }
  rem[12] = (rem[12] << 3) ^ bch_lookup_low[lookup_val_low][12];
  rem[0] &= 0x0f;


  //lastly append crc to data string shifting to take up the one bit space
  data_buffer[19] &= 0xe0; // crc byte zero shared with data byte so needs special care
  data_buffer[19] |= (rem[0] << 1) | (rem[1] >> 7);
  for(j=1; j<12; j++)
    data_buffer[j + 19] = (rem[j] << 1) + (rem[j+1] >> 7);
  data_buffer[31] = rem[12] << 1; //last bit will always read zero

}
